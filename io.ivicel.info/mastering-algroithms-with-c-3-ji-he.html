<!DOCTYPE html>
<html lang="zh" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>Mastering Algroithms with C-3: 集合 - Amber time</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="./mastering-algroithms-with-c-3-ji-he.html">

        <meta name="author" content="ivicel" />
        <meta name="keywords" content="算法,C,集合,数据结构" />
        <meta name="description" content="集合是不同对象的无序聚集 集合的成员是无序的 每一个成员只在集合中出现一次 集合的定义: 空集 集合相等 子集 集合操作: 交集 并集 差集 实现集合的一种好的方法是采用链表. 但每一次插入删除数据都需要遍历集合中的每一个成员, 时间复杂度 O(n) 由于性能问题, 顺序查找的方式只适合比较小型的集合数据, 可以使用哈希等查找技术提高效率 集合的抽象数据类型头文件定义 /* set.h */ #ifndef SET_H #define SET_H #include &lt;stdlib.h&gt; /* 集合元素 */ typedef struct SetElmt_ { void *data; struct SetElmt_ next; }SetElmt; /* 集合结构 */ typedef struct Set_ { /* 集合大小 */ int size; /* 指向集合头结点 */ SetElmt *head; /* 集合尾结点 …" />

        <meta property="og:site_name" content="Amber time" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="Mastering Algroithms with C-3: 集合"/>
        <meta property="og:url" content="./mastering-algroithms-with-c-3-ji-he.html"/>
        <meta property="og:description" content="集合是不同对象的无序聚集 集合的成员是无序的 每一个成员只在集合中出现一次 集合的定义: 空集 集合相等 子集 集合操作: 交集 并集 差集 实现集合的一种好的方法是采用链表. 但每一次插入删除数据都需要遍历集合中的每一个成员, 时间复杂度 O(n) 由于性能问题, 顺序查找的方式只适合比较小型的集合数据, 可以使用哈希等查找技术提高效率 集合的抽象数据类型头文件定义 /* set.h */ #ifndef SET_H #define SET_H #include &lt;stdlib.h&gt; /* 集合元素 */ typedef struct SetElmt_ { void *data; struct SetElmt_ next; }SetElmt; /* 集合结构 */ typedef struct Set_ { /* 集合大小 */ int size; /* 指向集合头结点 */ SetElmt *head; /* 集合尾结点 …"/>
        <meta property="article:published_time" content="2017-03-23" />
            <meta property="article:section" content="Data Structure Algorithms" />
            <meta property="article:tag" content="算法" />
            <meta property="article:tag" content="C" />
            <meta property="article:tag" content="集合" />
            <meta property="article:tag" content="数据结构" />
            <meta property="article:author" content="ivicel" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="./theme/css/bootstrap.min.css" type="text/css"/>
    <link href="./theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="./theme/css/pygments/default.css" rel="stylesheet">
    <link rel="stylesheet" href="./theme/css/style.css" type="text/css"/>





</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="./" class="navbar-brand">
Amber time            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li >
                            <a href="./category/android.html">Android</a>
                        </li>
                        <li >
                            <a href="./category/c-language.html">C language</a>
                        </li>
                        <li class="active">
                            <a href="./category/data-structure-algorithms.html">Data structure algorithms</a>
                        </li>
                        <li >
                            <a href="./category/database.html">Database</a>
                        </li>
                        <li >
                            <a href="./category/java.html">Java</a>
                        </li>
                        <li >
                            <a href="./category/javascript.html">Javascript</a>
                        </li>
                        <li >
                            <a href="./category/python.html">Python</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-sm-9">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="./mastering-algroithms-with-c-3-ji-he.html"
                       rel="bookmark"
                       title="Permalink to Mastering Algroithms with C-3: 集合">
                        Mastering Algroithms with C-3: 集合
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2017-03-23T00:00:00+08:00"> Thu 23 March 2017</time>
    </span>





<span class="label label-default">Tags</span>
	<a href="./tag/suan-fa.html">算法</a>
        /
	<a href="./tag/c.html">C</a>
        /
	<a href="./tag/ji-he.html">集合</a>
        /
	<a href="./tag/shu-ju-jie-gou.html">数据结构</a>
        
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>集合是不同对象的无序聚集</p>
<ol>
<li>集合的成员是无序的</li>
<li>每一个成员只在集合中出现一次</li>
</ol>
<p>集合的定义: </p>
<ul>
<li>空集</li>
<li>集合相等</li>
<li>子集</li>
</ul>
<p>集合操作:</p>
<ul>
<li>交集</li>
<li>并集</li>
<li>差集</li>
</ul>
<p>实现集合的一种好的方法是采用链表. 但每一次插入删除数据都需要遍历集合中的每一个成员, 时间复杂度 O(n)</p>
<p>由于性能问题, 顺序查找的方式只适合比较小型的集合数据, 可以使用哈希等查找技术提高效率</p>
<p>集合的抽象数据类型头文件定义</p>
<div class="highlight"><pre><span></span><span class="cm">/* set.h */</span>
<span class="cp">#ifndef SET_H</span>
<span class="cp">#define SET_H</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="cm">/* 集合元素 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">SetElmt_</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">SetElmt_</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="n">SetElmt</span><span class="p">;</span>
<span class="cm">/* 集合结构 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Set_</span> <span class="p">{</span>
    <span class="cm">/* 集合大小 */</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="cm">/* 指向集合头结点 */</span>
    <span class="n">SetElmt</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="cm">/* 集合尾结点 */</span>
    <span class="n">SetElmt</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="cm">/* 判断 key1 是否等于 key2, 相等返回 1, 否则返回 0 */</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">);</span>
<span class="p">}</span><span class="n">Set</span><span class="p">;</span>

<span class="cm">/* 初始化 */</span>
<span class="kt">void</span> <span class="nf">set_init</span><span class="p">(</span><span class="n">Set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">),</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>
<span class="cm">/* 销毁 */</span>
<span class="kt">void</span> <span class="nf">set_destroy</span><span class="p">(</span><span class="n">Set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
<span class="cm">/* 插入结点 */</span>
<span class="kt">int</span> <span class="nf">set_insert</span><span class="p">(</span><span class="n">Set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 删除结点 */</span>
<span class="kt">int</span> <span class="nf">set_remove</span><span class="p">(</span><span class="n">Set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 求并集 */</span>
<span class="kt">int</span> <span class="nf">set_union</span><span class="p">(</span><span class="n">Set</span> <span class="o">*</span><span class="n">setu</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set2</span><span class="p">);</span>
<span class="cm">/* 求交集 */</span>
<span class="kt">int</span> <span class="nf">set_intersection</span><span class="p">(</span><span class="n">Set</span> <span class="o">*</span><span class="n">seti</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set2</span><span class="p">);</span>
<span class="cm">/* 求差集 */</span>
<span class="kt">int</span> <span class="nf">set_difference</span><span class="p">(</span><span class="n">Set</span> <span class="o">*</span><span class="n">setd</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set2</span><span class="p">);</span>
<span class="cm">/* 判断是否是集合成员 */</span>
<span class="kt">int</span> <span class="nf">set_is_member</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 判断是否是了集 */</span>
<span class="kt">int</span> <span class="nf">set_is_subset</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set2</span><span class="p">);</span>
<span class="cm">/* 判断集合是否相等 */</span>
<span class="kt">int</span> <span class="nf">set_is_equal</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set2</span><span class="p">);</span>
<span class="cm">/* 返回集合大小 */</span>
<span class="cp">#define set_size(set) ((set)-&gt;size)</span>

<span class="cp">#endif</span>
</pre></div>


<p>集合抽象数据类型的实现</p>
<div class="highlight"><pre><span></span><span class="cm">/* set.c */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;set.h&quot;</span><span class="cp"></span>

<span class="cm">/* 初始化 */</span>
<span class="kt">void</span> <span class="nf">set_init</span><span class="p">(</span><span class="n">Set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">),</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>
<span class="p">{</span>
    <span class="n">set</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">set</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">set</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">set</span><span class="p">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">match</span><span class="p">;</span>
    <span class="n">set</span><span class="p">.</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 销毁 */</span>
<span class="kt">void</span> <span class="n">set_destroy</span><span class="p">(</span><span class="n">Set</span> <span class="o">*</span><span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">set_remove</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">set</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Set</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* 插入集合 */</span>
<span class="kt">int</span> <span class="n">set_insert</span><span class="p">(</span><span class="n">Set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 重复数据 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">set_is_member</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">_insert_into_set</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* 删除元素 */</span>
<span class="kt">int</span> <span class="n">set_remove</span><span class="p">(</span><span class="n">Set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SetElmt</span> <span class="o">*</span><span class="n">member</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> 
        <span class="cm">/* 用以检测 set-&gt;head 就是所查找的结点 */</span>
        <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">NUll</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">member</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">member</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">member</span><span class="p">;</span>
        <span class="n">member</span> <span class="o">=</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">member</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 头结点是查找的结点 */</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
    <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">member</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">member</span><span class="p">);</span>
    <span class="n">set</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 并集 */</span>
<span class="kt">int</span> <span class="n">set_union</span><span class="p">(</span><span class="n">Set</span> <span class="o">*</span><span class="n">setu</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SetElmt</span> <span class="o">*</span><span class="n">member</span><span class="p">;</span>

    <span class="cm">/* set-&gt;destroy 设为 NULL, 避免失败将还有引用的 data 破坏 */</span>
    <span class="n">set_init</span><span class="p">(</span><span class="n">setu</span><span class="p">,</span> <span class="n">set1</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">member</span> <span class="o">=</span> <span class="n">set1</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span> <span class="n">member</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">member</span> <span class="o">=</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 复制 set1 到 setu 中, data 的指向是同一个地址 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_insert_into_set</span><span class="p">(</span><span class="n">setu</span><span class="p">,</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">set_destroy</span><span class="p">(</span><span class="n">setu</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">member</span> <span class="o">=</span> <span class="n">set2</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">member</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">member</span> <span class="o">=</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">set_insert</span><span class="p">(</span><span class="n">setu</span><span class="p">,</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">set_destroy</span><span class="p">(</span><span class="n">setu</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 交集 */</span>
<span class="kt">int</span> <span class="n">set_intersection</span><span class="p">(</span><span class="n">Set</span> <span class="o">*</span><span class="n">seti</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SetElmt</span> <span class="o">*</span><span class="n">member</span><span class="p">;</span>

    <span class="n">set_init</span><span class="p">(</span><span class="n">seti</span><span class="p">,</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">member</span> <span class="o">=</span> <span class="n">set1</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span> <span class="n">member</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">member</span> <span class="o">=</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">set_is_member</span><span class="p">(</span><span class="n">set2</span><span class="p">,</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_insert_into_set</span><span class="p">(</span><span class="n">seti</span><span class="p">,</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">set_destroy</span><span class="p">(</span><span class="n">seti</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 差集 set1 - set2*/</span>
<span class="kt">int</span> <span class="n">set_difference</span><span class="p">(</span><span class="n">Set</span> <span class="o">*</span><span class="n">setd</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SetElmt</span> <span class="o">*</span><span class="n">member</span><span class="p">;</span>

    <span class="n">set_init</span><span class="p">(</span><span class="n">setd</span><span class="p">,</span> <span class="n">set1</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">member</span> <span class="o">=</span> <span class="n">set1</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span> <span class="n">member</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">member</span> <span class="o">=</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">set_is_member</span><span class="p">(</span><span class="n">set2</span><span class="p">,</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_insert_into_set</span><span class="p">(</span><span class="n">setd</span><span class="p">,</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">set_destroy</span><span class="p">(</span><span class="n">setd</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 检查是否是集合元素 */</span>
<span class="kt">int</span> <span class="n">set_is_member</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SetElmt</span> <span class="o">*</span><span class="n">member</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">member</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span> <span class="n">member</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">member</span> <span class="o">=</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">member</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* set1 是否是 set2 的子集*/</span>
<span class="kt">int</span> <span class="n">set_is_subset</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SetElmt</span> <span class="o">*</span><span class="n">member</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">set1</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">set2</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">member</span> <span class="o">=</span> <span class="n">set1</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span> <span class="n">member</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">member</span> <span class="o">=</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">set_is_member</span><span class="p">(</span><span class="n">set2</span><span class="p">,</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 集合相等 */</span>
<span class="kt">int</span> <span class="n">set_is_equal</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span> <span class="o">*</span><span class="n">set2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SetElmt</span> <span class="o">*</span><span class="n">member</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">set1</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">!=</span> <span class="n">set2</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">set_is_subset</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* 不检查重复的集合元素, 不要直接在集合外直接调用 */</span>
<span class="kt">int</span> <span class="n">_insert_into_set</span><span class="p">(</span><span class="n">Set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SetElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">element</span> <span class="o">=</span> <span class="p">(</span><span class="n">SetElmt</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">SetElmt</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">element</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 空集 */</span>
        <span class="n">set</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">set</span><span class="o">-&gt;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">set</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
    <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">set</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p><strong>集合覆盖</strong></p>
<p>给定一个集合 S, 集合 P 由集合 S 的子集 A<sub>1</sub> 到 A<sub>n</sub> 组成, 集合 C 由集合 P 中的一个或多个子集组成.
如果 S 中的每个成员都包含在 C 的至少一个子集中, 则称集合 C 覆盖集合 S
C 包含的 P 的子集应该越少越好</p>
<blockquote>
<p>以下程序使用一种贪心法算法, 每一次都尝试尽可能的覆盖到更多的成员, 得到不一定是最优解</br>
给定一个集合, 代表有 12 各技能: S = {a, b, c, d, e, f, g, h, i, j, k, l}</br>
然后一共有 7 名选手 P = {A<sub>1</sub>, A<sub>2</sub>, …, A<sub>7</sub>}</br>
每一位选手都有不同的技能: </br></p>
<blockquote>
<p>A<sub>1</sub> = {a, b, c, d}</br>
A<sub>2</sub> = {e, f, g, h, i}</br>
A<sub>3</sub> = {j, k, l}</br>
A<sub>4</sub> = {a, e}</br>
A<sub>5</sub> = {b, f, g}</br>
A<sub>6</sub> = {c, d, g, h, k, l}</br>
A<sub>7</sub> = {l}</br>
最优解的集合覆盖是 C = {A<sub>1</sub> , A<sub>2</sub> , A<sub>3</sub>}</br>
不过我们的程序给出了的是 C = {A<sub>6</sub>, A<sub>2</sub>, A<sub>1</sub>, A<sub>3</sub>}</br></p>
</blockquote>
</blockquote>
<p><img alt="集合覆盖" src="../images/集合覆盖.png" /></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;set.h&quot;</span><span class="cp"></span>

<span class="cm">/* 集合 P 元素结点结构 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">KSet_</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
    <span class="n">Set</span> <span class="n">set</span><span class="p">;</span>
<span class="p">}</span><span class="n">KSet</span><span class="p">;</span>

<span class="cm">/* 函数在集合 P 的子集 A&lt;sub&gt;1&lt;/sub&gt;~A&lt;sub&gt;n&lt;/sub&gt; 中挑选出能够覆盖集合 S 的近似最优解 </span>
<span class="cm"> * @param members: 待覆盖的集合 S</span>
<span class="cm"> * @param subsets: 集合 P 中的子集</span>
<span class="cm"> * @param covering: 作为返回的覆盖集合 C</span>
<span class="cm"> *</span>
<span class="cm"> * 函数首先初始化 covering, 只要 members 中的还有未覆盖的成员, 且 subsets 中的</span>
<span class="cm"> * 子集还没有挑选完, 就继续迭代最外层循环</span>
<span class="cm"> * 在循环中,每次迭代时都在 subsets 中找出能够覆盖到 members 的最大交集</span>
<span class="cm"> * 然后将这个集合加到覆盖集 covering 中并把它的成员从 members 中移除</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cover</span><span class="p">(</span><span class="n">Set</span> <span class="o">*</span><span class="n">members</span><span class="p">,</span> <span class="n">Set</span> <span class="o">*</span><span class="n">subsets</span><span class="p">,</span> <span class="n">Set</span> <span class="o">*</span><span class="n">covering</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Set</span> <span class="n">intersection</span><span class="p">;</span>
    <span class="n">KSet</span> <span class="o">*</span><span class="n">subset</span><span class="p">;</span>
    <span class="n">SetElmt</span> <span class="o">*</span><span class="n">member</span><span class="p">,</span> <span class="o">*</span><span class="n">max_member</span><span class="p">;</span>

    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">max_size</span><span class="p">;</span>
    <span class="cm">/* 初始化 covering */</span>
    <span class="n">set_init</span><span class="p">(</span><span class="n">covering</span><span class="p">,</span> <span class="n">subsets</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">set_size</span><span class="p">(</span><span class="n">members</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">set_size</span><span class="p">(</span><span class="n">subsets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Find the subset that covers the most members */</span>
        <span class="n">max_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="cm">/* 循环集合 P 中的元素 */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">member</span> <span class="o">=</span> <span class="n">subsets</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span> <span class="n">member</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">member</span> <span class="o">=</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 求 P 中元素结点和 S 的交集, 如果 P 中有结点中的元素完全不属于 S, 返回错误 */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">set_intersection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intersection</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">((</span><span class="n">KSet</span> <span class="o">*</span><span class="p">)</span><span class="n">member</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">,</span>
                <span class="n">members</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="cm">/* 贪心法, 只保留最大能产生最多交集元素的结点 */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">set_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intersection</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_size</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">max_member</span> <span class="o">=</span> <span class="n">member</span><span class="p">;</span>
                <span class="n">max_size</span> <span class="o">=</span> <span class="n">set_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intersection</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="cm">/* 重置中间集合, 以便循环使用 */</span>
            <span class="n">set_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intersection</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/* 检查查找到子集, 若没有匹配到 P 和 S 任何交集, 返回失败. 因为空集是任何集合的子集 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">max_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/* 将查找到的 P 中的结点加入集合 C 中 */</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="p">(</span><span class="n">KSet</span> <span class="o">*</span><span class="p">)</span><span class="n">max_member</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">set_insert</span><span class="p">(</span><span class="n">covering</span><span class="p">,</span> <span class="n">subset</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/* 将查找到的 P 集合中的结点里的属于集合 S 中的数据从 集合 S 中删除掉 */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">member</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">subset</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
            <span class="n">member</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">member</span> <span class="o">=</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">set_remove</span><span class="p">(</span><span class="n">members</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> 
                <span class="n">members</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">members</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* 将该次选中的 P 集合中的结点从集合 P 中删除. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">set_remove</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">subset</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* 在查找完 P 集合中所有结点, 依然没有覆盖完 S 的所有元素时, 返回失败 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">set_size</span><span class="p">(</span><span class="n">members</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
        <div class="col-sm-3" id="sidebar">
            <aside>

<section class="well well-sm">
    <ul class="list-group list-group-flush">
        <li class="list-group-item"><h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Social</span></h4>
              <ul class="list-group" id="social">
                <li class="list-group-item"><a href="#"><i class="fa fa-you-can-add-links-in-your-config-file-square fa-lg"></i> You can add links in your config file</a></li>
                <li class="list-group-item"><a href="#"><i class="fa fa-another-social-link-square fa-lg"></i> Another social link</a></li>
              </ul>
            </li>





    <li class="list-group-item"><h4><i class="fa fa-external-link-square fa-lg"></i><span class="icon-label">Links</span></h4>
      <ul class="list-group" id="links">
        <li class="list-group-item">
            <a href="http://getpelican.com/" target="_blank">
                Pelican
            </a>
        </li>
        <li class="list-group-item">
            <a href="http://python.org/" target="_blank">
                Python.org
            </a>
        </li>
        <li class="list-group-item">
            <a href="http://jinja.pocoo.org/" target="_blank">
                Jinja2
            </a>
        </li>
        <li class="list-group-item">
            <a href="#" target="_blank">
                You can modify those links in your config file
            </a>
        </li>
      </ul>
    </li>
    </ul>
</section>            </aside>
        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2018 ivicel
            &middot; Powered by <a href="https://github.com/getpelican/pelican-themes/tree/master/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="./theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="./theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="./theme/js/respond.min.js"></script>


</body>
</html>