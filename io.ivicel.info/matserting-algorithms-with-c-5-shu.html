
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index, follow" />

  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:300,400,400i,700" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="./theme/pygments/manni.min.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/font-awesome.min.css">

    <link href="./static/custom.css" rel="stylesheet">



    <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/images/favicon.ico" type="image/x-icon">

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-113622715-2', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->

<meta name="author" content="ivicel" />
<meta name="description" content="二叉树(Binary tree) 先序遍历: 根结点-&gt;左子结点-&gt;右子结点 中序遍历: 左子结点-&gt;根结点-&gt;右子结点 后序遍历: 左子结点-&gt;右子结点-&gt;根结占 层级遍历: 树根结点-&gt;下层左结点-&gt;该层右结点 (广度优先方法) 树的平衡是指在添加结点到下一层是必须保证本层的结点是满额的 二叉的接口定义 /* 这里不没包含插入和删除非叶子结点的操作, 这些操作需要根据具体的应用将树中的其他结点做相应的调整 */ /* bitree.h */ #ifndef BITREE_H #define BITREE_H #include &lt;stdlib.h&gt; /* 节点结构 */ typedef struct BiTreeNode_ { void *data; /* 左结点 */ struct BiTreeNode_ *left; /* 右结点 */ struct BiTreeNode_ *right; }BiTreeNode; /* 二叉树结构 */ typedef …" />
<meta name="keywords" content="算法, C, 集合, 数据结构">

<meta property="og:site_name" content="Ivicel's Ambertime"/>
<meta property="og:title" content="Matserting Algorithms with C-5: 树"/>
<meta property="og:description" content="二叉树(Binary tree) 先序遍历: 根结点-&gt;左子结点-&gt;右子结点 中序遍历: 左子结点-&gt;根结点-&gt;右子结点 后序遍历: 左子结点-&gt;右子结点-&gt;根结占 层级遍历: 树根结点-&gt;下层左结点-&gt;该层右结点 (广度优先方法) 树的平衡是指在添加结点到下一层是必须保证本层的结点是满额的 二叉的接口定义 /* 这里不没包含插入和删除非叶子结点的操作, 这些操作需要根据具体的应用将树中的其他结点做相应的调整 */ /* bitree.h */ #ifndef BITREE_H #define BITREE_H #include &lt;stdlib.h&gt; /* 节点结构 */ typedef struct BiTreeNode_ { void *data; /* 左结点 */ struct BiTreeNode_ *left; /* 右结点 */ struct BiTreeNode_ *right; }BiTreeNode; /* 二叉树结构 */ typedef …"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="./matserting-algorithms-with-c-5-shu.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2017-03-27 00:00:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="./author/ivicel.html">
<meta property="article:section" content="Data Structure Algorithms"/>
<meta property="article:tag" content="算法"/>
<meta property="article:tag" content="C"/>
<meta property="article:tag" content="集合"/>
<meta property="article:tag" content="数据结构"/>
<meta property="og:image" content="/images/favicon.ico">

  <title>Ivicel's Ambertime &ndash; Matserting Algorithms with C-5: 树</title>

</head>
<body>
  <aside>
    <div>
      <a href=".">
        <img src="/images/favicon.ico" alt="Ambertime" title="Ambertime">
      </a>
      <h1><a href=".">Ambertime</a></h1>

<p>Make memory in past times</p>

      <ul class="social">
      </ul>
    </div>


  </aside>
  <main>

    <nav>
      <a href=".">Home</a>



    </nav>

<article class="single">
  <header>
      
    <h1 id="matserting-algorithms-with-c-5-shu">Matserting Algorithms with C-5: 树</h1>
    <p>
      Posted on Mon 27 March 2017 in <a href="./category/data-structure-algorithms.html">Data Structure Algorithms</a>

    </p>
  </header>


  <div>
    <h3 id="binary-tree">二叉树(Binary tree)</h3>
<p><img alt="二叉树" src="../images/二叉树.png" /></p>
<p><strong>先序遍历</strong>: 根结点-&gt;左子结点-&gt;右子结点</p>
<p><strong>中序遍历</strong>: 左子结点-&gt;根结点-&gt;右子结点</p>
<p><strong>后序遍历</strong>: 左子结点-&gt;右子结点-&gt;根结占</p>
<p><strong>层级遍历</strong>: 树根结点-&gt;下层左结点-&gt;该层右结点 (广度优先方法)</p>
<p><img alt="树的遍历方法" src="../images/树的遍历方法.png" /></p>
<blockquote>
<p>树的平衡是指在添加结点到下一层是必须保证本层的结点是满额的</p>
</blockquote>
<p>二叉的接口定义</p>
<div class="codehilite"><pre><span></span><span class="cm">/* 这里不没包含插入和删除非叶子结点的操作, 这些操作需要根据具体的应用将树中的其他结点做相应的调整 */</span>
<span class="cm">/* bitree.h */</span>
<span class="cp">#ifndef BITREE_H</span>
<span class="cp">#define BITREE_H</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="cm">/* 节点结构 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">BiTreeNode_</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="cm">/* 左结点 */</span>
    <span class="k">struct</span> <span class="n">BiTreeNode_</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
    <span class="cm">/* 右结点 */</span>
    <span class="k">struct</span> <span class="n">BiTreeNode_</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
<span class="p">}</span><span class="n">BiTreeNode</span><span class="p">;</span>

<span class="cm">/* 二叉树结构 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">BiTree_</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="cm">/* 为二叉搜索树使用, 比较两结点的大小, key1&gt;key2 返回 1, 小于返回 -1, 相等返回 0 */</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
<span class="p">}</span><span class="n">BiTree</span><span class="p">;</span>
<span class="cm">/* 初始化 */</span>
<span class="kt">void</span> <span class="nf">bitree_init</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>
<span class="cm">/* 销毁 */</span>
<span class="kt">void</span> <span class="nf">bitree_destroy</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">);</span>
<span class="cm">/* 插入左结点 */</span>
<span class="kt">void</span> <span class="nf">bitree_ins_left</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 插入右结点 */</span>
<span class="kt">void</span> <span class="nf">bitree_ins_right</span><span class="p">(</span><span class="n">biTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 删除结点以及其下层全部的子结点, 并未实现只删除任意结点而不删除子结点 */</span>
<span class="kt">void</span> <span class="nf">bitree_rem_left</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">bitree_rem_right</span><span class="p">(</span><span class="n">biTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>
<span class="cm">/* 将两棵树合成新的二叉树, data 为根结点 */</span>
<span class="kt">int</span> <span class="nf">bitree_merge</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">merge</span><span class="p">,</span> <span class="n">BiTree</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="n">BiTree</span> <span class="o">*</span><span class="n">right</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cp">#define bitree_size(tree) ((tree)-&gt;size)</span>
<span class="cp">#define bitree_root(tree) ((tree)-&gt;root)</span>
<span class="cp">#define bitree_is_eob(node) ((ndoe) == NULL)</span>
<span class="cp">#define bitree_is_leaf(node) ((node)-&gt;left == NULL &amp;&amp; (node)-&gt;rigth == NULL)</span>
<span class="cp">#define bitree_data(node) ((node)-&gt;data)</span>
<span class="cp">#define bitree_left(node) ((node)-&gt;left)</span>
<span class="cp">#define bitree_right(node) ((ndoe)-&gt;right)</span>

<span class="cp">#endif</span>
</pre></div>


<p>二叉树的实现 </p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;bitree.h&quot;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">bitree_init</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">;</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bitree_destroy</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bitree_rem_left</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BiTree</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bitree_ins_left</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">new_node</span><span class="p">,</span> <span class="o">**</span><span class="n">position</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bitree_size</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/* node 为 NULL 并且树为空时, 作根结点 */</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bitree_left</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 已有左结点 */</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span> 
    <span class="p">}</span>
    <span class="cm">/* 申请内存 */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">new_node</span> <span class="o">=</span> <span class="p">(</span><span class="n">BiTreeNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BiTreeNode</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="o">*</span><span class="n">position</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bitree_ins_right</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">new_node</span><span class="p">,</span> <span class="o">**</span><span class="n">position</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bitree_size</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bitree_right</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">new_node</span> <span class="o">=</span> <span class="p">(</span><span class="n">BiTreeNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BiTreeNode</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">new_ndoe</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="o">*</span><span class="n">position</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bitree_rem_left</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BiTreeNode</span> <span class="o">**</span><span class="n">position</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">bitree_size</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 传入 NULL 删除根结点 */</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 确定是否有左结点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">position</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">bitree_rem_left</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="n">bitree_rem_right</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">((</span><span class="o">*</span><span class="n">position</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="o">*</span><span class="n">position</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">tree</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bitree_rem_right</span><span class="p">(</span><span class="n">biTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BiTreeNode</span> <span class="o">**</span><span class="n">position</span><span class="p">;</span>
    <span class="cm">/* 空树 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bitree_size</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* 传入 NULL 删除根结点下右结点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 确认有右结点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">position</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">bitree_rem_left</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="n">biTree_rem_right</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">((</span><span class="o">*</span><span class="n">position</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="n">tree</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bitree_merge</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">merge</span><span class="p">,</span> <span class="n">BiTree</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="n">BiTree</span> <span class="o">*</span><span class="n">right</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bitree_init</span><span class="p">(</span><span class="n">merge</span><span class="p">,</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">);</span>
    <span class="cm">/* 设置新树根结点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bitree_ins_left</span><span class="p">(</span><span class="n">merge</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">bitree_destroy</span><span class="p">(</span><span class="n">merge</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">bitree_root</span><span class="p">(</span><span class="n">merge</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">bitree_root</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
    <span class="n">bitree_root</span><span class="p">(</span><span class="n">merge</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">bitree_root</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
    <span class="cm">/* 合并后树的大小 */</span>
    <span class="n">merge</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">merge</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+</span> <span class="n">bitree_size</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">bitree_size</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>

    <span class="cm">/* 将原先的左, 右树结点的大小和根结点重置 */</span>
    <span class="n">left</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">left</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">right</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">right</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>遍历二叉树的实现</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;list.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;bitree.h&quot;</span><span class="cp"></span>
<span class="cm">/* 前序遍历 */</span>
<span class="kt">int</span> <span class="nf">preorder</span><span class="p">(</span><span class="k">const</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">List</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 非空结点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* 将数据加入到列表尾部 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list_ins_next</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">list_tail</span><span class="p">(</span><span class="n">list</span><span class="p">),</span> <span class="n">bitree_data</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/* 递归左结点 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">bitree_left</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">bitree_left</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* 递归右结点 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">bitree_right</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">bitree_right</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* 中序遍历 */</span>
<span class="kt">int</span> <span class="nf">inorder</span><span class="p">(</span><span class="k">const</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">List</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 非 NULL 结点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* 查找左结点, 如果存在递归到末尾叶子结点 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">bitree_left</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">bitree_left</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* 将结点加到队列中 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list_ins_next</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">list_tail</span><span class="p">(</span><span class="n">list</span><span class="p">),</span> <span class="n">bitree_data</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/* 查找右结点 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">bitree_right</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">bitree_right</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* 后序遍历 */</span>
<span class="kt">int</span> <span class="nf">postorder</span><span class="p">(</span><span class="k">const</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">List</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 非空结点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* 先递归左结点, 将左结点加入到队列中 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">bitree_left</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">postorder</span><span class="p">(</span><span class="n">bitree_left</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* 再递归右结点 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">bitree_right</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">postorder</span><span class="p">(</span><span class="n">bitree_right</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* 结点加入到队列 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list_ins_next</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">list_tail</span><span class="p">(</span><span class="n">list</span><span class="p">),</span> <span class="n">bitree_data</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h3 id="_1">二叉搜索树</h3>
<p>二叉搜索树中, 左结点总比根小, 右结点总比根大</p>
<p>在二叉搜索树中查询一个结点, 从根结点开始, 当遇到一个比目标结点值大的结点时, 顺着该结点的左结点查找; 如果遇到的结点小于目标结点时, 则顺着该结点的右子树查找, 一直查到叶子结点</p>
<p>只有当二叉搜索树保持平衡时其查找效率才是最高. 一种方法是将二叉树实现为 AVL树(Adel'son-Vel'skii and Landis)</p>
<p>AVL树是一种特殊类型的二叉树, 它的每个结点都保存一份额外信息--结点的平衡因子</p>
<p>结点的平衡因子 = 左子树高度 - 右子树高度</p>
<ul>
<li>+1 表示左倾斜(left-heavy)</li>
<li>-1 表示右倾斜(rigth-heavy)</li>
<li>0 表示平衡(left-heavy)</li>
</ul>
<p><img alt="AVL树" src="../images/AVL树.png" /></p>
<p>向 AVL树中插入一个结点时, 必须计算因为执行了插入操作对平衡因子带来的改; 其次, 如果任何平衡因子为变为了±2, 就必须从这个结点开始往下重新平衡这棵树, 重新平衡的过程称为旋转</p>
<p><strong>LL(left-left)旋转</strong></p>
<p>当 x 位于 A 的左子树下的左子树上, 执行 LL 旋转. 设 left 为 A 的左子树, 将 A 的左指针指向 left 的右结点, left 的右指针指向 A, 将原来指向 A 的指针改为指向 left, 旋转后, A 和 left 的平衡因子都改为 0</p>
<p><img alt="LL旋转" src="../images/LL旋转.png" /></p>
<p><strong>LR(left-right)旋转</strong></p>
<p>当 x 位于 A 的左子树下的右子树上时, 执行 LR 旋转. 设 left 是 A 的左子结点, A 的子孙结点 grandchild 为 left 的右子结点. 要执行 LR旋转, 将 left 的右子结点指向 grandchild 的左子结点, grandchild 的左子结点指向 left, A 的左子结点指向 grandchild 的右子结点, 再将 grandchild 的右子结点指向 A, 最后将原来指向 A 的指针指向 grandchild</p>
<p><img alt="LR旋转" src="../images/LR旋转.png" /></p>
<p>执行 LR 旋转后, 调整结点的平衡因子取决于旋转前 grandchild 结点的原平衡因子值</p>
<p>下方的图展示了 3 种需要考虑到的情况</p>
<p>如果 grandchild 结点的原始平衡因子为+1, 就将 A 的平衡因子设置为-1, 将 left 结点的平衡因子设置为 0</p>
<p>如果 grandchild 结点的原始平衡因子为 0, 就将 A 和 left 结点的平衡因为都设置为 0</p>
<p>如果 grandchild 结点的原始平衡因子为-1, 就将 A 的平衡因子设置为 0, 将 left 的平衡因为设置为+1</p>
<p><img alt="LR旋转后更新" src="../images/LR旋转后更新.png" /></p>
<p><strong>RR(right-right)旋转</strong></p>
<p>当 x 位于 A 的右子树下的右子树上时, 执行 RL 旋转. RR 旋转与 LL 旋转是对称关系. 设 A 的右结点为 right, 要执行 RR 旋转, 将 A 的右指针指向 right 的左子结点, right 的左指针指向 A, 原来指向 A 的指针修改为指向 right</p>
<p><strong>RL(right-left)旋转</strong></p>
<p>当 x 位于 A 的右子树下的左子树上的时, 执行 RL 旋转. RL 旋转与 LR 旋转是对称关系. 设 A 的右结点为 right, right 的左子结点为 grandchild. 要执行 RL 旋转, 将 right 结点的左子结点指向 grandchild 的右子结点, 将 grandchild 的右子结点指向 right, 将 A 的右子结点指向 grandchild 的左子结点, 将 grandchild 的左子结点指向 A, 最后将原来指向 A 的指针指向 grandchild</p>
<p>如果 grandchild 结点的原始平衡因子为+1, 就将 A 的平衡因子设置为 0, 将 right 结点的平衡因子设置为 -1</p>
<p>如果 grandchild 结点的原始平衡因子为 0, 就将 A 和 left 结点的平衡因为都设置为 0</p>
<p>如果 grandchild 结点的原始平衡因子为-1, 就将 A 的平衡因子设置为 +1, 将 right 的平衡因为设置为0</p>
<p>二叉搜索树头文件</p>
<div class="codehilite"><pre><span></span><span class="cp">#ifndef BISTREE_H</span>
<span class="cp">#define BISTREE_H</span>

<span class="cp">#include</span> <span class="cpf">&quot;bitree.h&quot;</span><span class="cp"></span>

<span class="cp">#define AVL_LFT_HEAVY 1</span>
<span class="cp">#define AVL_BALANCED 0</span>
<span class="cp">#define AVL_RGT_HEAVY -1</span>

<span class="cm">/* AVL 树结点结构 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">AvlNode_</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="cm">/* 销毁结点后, 指向的数据被未被销毁时设置结点为隐藏 */</span>
    <span class="kt">int</span> <span class="n">hidden</span><span class="p">;</span>
    <span class="cm">/* 平衡因子 */</span>
    <span class="kt">int</span> <span class="n">factor</span><span class="p">;</span>
<span class="p">}</span><span class="n">AvlNode</span><span class="p">;</span>


<span class="k">typedef</span> <span class="n">BiTree</span> <span class="n">BisTree</span>

<span class="kt">void</span> <span class="nf">bistree_init</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">),</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>
<span class="kt">void</span> <span class="nf">bistree_destroy</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">bistree_insert</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">bistree_remove</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">bistree_lookup</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">);</span>

<span class="cp">#define bistree_size(tree) ((tree)-&gt;size)</span>

<span class="cp">#endif</span>
</pre></div>


<p>二叉搜索树实现</p>
<div class="codehilite"><pre><span></span><span class="cm">/* bistree.c */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;bistree.h&quot;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_right</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>

<span class="cm">/* 左旋转 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rotate_left</span><span class="p">(</span><span class="n">BiTreeNode</span> <span class="o">**</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">grandchild</span><span class="p">;</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">bitree_left</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">left</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">==</span> <span class="n">AVL_LFT_HEAVY</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Perform an LL rotation */</span>
        <span class="n">bitree_left</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="n">bitree_right</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
        <span class="n">bitree_right</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">left</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
        <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">grandchild</span> <span class="o">=</span> <span class="n">bitree_right</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
        <span class="n">bitree_right</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">=</span> <span class="n">bitree_left</span><span class="p">(</span><span class="n">grandchild</span><span class="p">);</span>
        <span class="n">bitree_left</span><span class="p">(</span><span class="n">grandchild</span><span class="p">)</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
        <span class="n">bitree_left</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="n">bitree_right</span><span class="p">(</span><span class="n">grandchild</span><span class="p">);</span>
        <span class="n">bitree_right</span><span class="p">(</span><span class="n">grandchild</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

        <span class="k">switch</span> <span class="p">(((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">grandchild</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nl">AVL_LFT_HEAVY</span><span class="p">:</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_RGT_HEAVY</span><span class="p">;</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">left</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="k">case</span> <span class="nl">AVL_BALANCED</span><span class="p">:</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">left</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="k">case</span> <span class="nl">AVL_RGT_HEAVY</span><span class="p">:</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">left</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_LFT_HEAVY</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">grandchild</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
        <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">grandchild</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 右旋转 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rotate_right</span><span class="p">(</span><span class="n">BiTreeNode</span> <span class="o">**</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">,</span> <span class="o">*</span><span class="n">grandchild</span><span class="p">;</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">bitree_right</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">right</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">==</span> <span class="n">AVL_RGT_HEAVY</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* perform an RR rotation */</span>
        <span class="n">bitree_right</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="n">bitree_left</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
        <span class="n">bitree_left</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">right</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
        <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* perform an RL rotation */</span>
        <span class="n">grandchild</span> <span class="o">=</span> <span class="n">bitree_left</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
        <span class="n">bitree_left</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">=</span> <span class="n">bitree_right</span><span class="p">(</span><span class="n">grandchild</span><span class="p">);</span>
        <span class="n">bitree_right</span><span class="p">(</span><span class="n">grandchild</span><span class="p">)</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
        <span class="n">bitree_right</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="n">bitree_left</span><span class="p">(</span><span class="n">grandchild</span><span class="p">);</span>
        <span class="n">bitree_left</span><span class="p">(</span><span class="n">grandchild</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

        <span class="k">switch</span> <span class="p">(((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">grandchild</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nl">AVL_LFT_HEAVY</span><span class="p">:</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">right</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_RGT_HEAVY</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="nl">AVL_BALANCED</span><span class="p">:</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">right</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="nl">AVL_RGT_HEAVY</span><span class="p">:</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_LFT_HEAVY</span><span class="p">;</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">right</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">grandchild</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
        <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">grandchild</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_left</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BiTreeNode</span> <span class="o">**</span><span class="n">position</span><span class="p">;</span>

    <span class="cm">/* do not allow destructionn of an empty tree */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bitree_size</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* determine where to destroy nodes */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* destroy the nodes */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">position</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">destroy_left</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="n">destroy_right</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">position</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* call a user-defined function to free dynamically allocated data */</span>
            <span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="n">position</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* free the AVL data in the node, then free the node itself */</span>
        <span class="n">free</span><span class="p">((</span><span class="o">*</span><span class="n">position</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="o">*</span><span class="n">position</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="cm">/* adjust the size of the tree to account for the destroyed node */</span>
        <span class="n">tree</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_right</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BiTreeNode</span> <span class="o">**</span><span class="n">position</span><span class="p">;</span>

    <span class="cm">/* do not allow destruction of an empty tree */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bitree_size</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* determine where to destroy nodes */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* destroy the nodes */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">position</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">destroy_left</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="n">destroy_right</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">position</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* call a user-defined function to free dynamically allocated data */</span>
            <span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="n">position</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* free the AVL data in the node, then free the node itself */</span>
        <span class="n">free</span><span class="p">((</span><span class="o">*</span><span class="n">position</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="o">*</span><span class="n">position</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="cm">/* adjust the size of the tree to account for the destroy node */</span>
        <span class="n">tree</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">insert</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">**</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">balanced</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">AvlNode</span> <span class="o">*</span><span class="n">avl_data</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cmpval</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

    <span class="cm">/* insert the data into the tree */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* handle insertion into an empty tree */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">avl_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">AvlNode</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">avl_data</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
        <span class="n">avl_data</span><span class="o">-&gt;</span><span class="n">hidden</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">avl_data</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">bitree_ins_left</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">avl_data</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* handle insertion into a tree that is not empty */</span>
        <span class="n">cmpval</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">compare</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cmpval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* move to the left */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">bitree_left</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">avl_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">AvlNode</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">avl_data</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="n">avl_data</span><span class="o">-&gt;</span><span class="n">hidden</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">avl_data</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">bitree_ins_left</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">avl_data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="o">*</span><span class="n">balanced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bitree_left</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">),</span> <span class="n">data</span><span class="p">,</span> <span class="n">balanced</span><span class="p">))</span> 
                    <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="cm">/* ensure that the tree remains balance */</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">balanced</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">switch</span> <span class="p">(((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">case</span> <span class="nl">AVL_LFT_HEAVY</span><span class="p">:</span>
                        <span class="n">rotate_left</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
                        <span class="o">*</span><span class="n">balanced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="nl">AVL_BALANCED</span><span class="p">:</span>
                        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_LFT_HEAVY</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="nl">AVL_RGT_HEAVY</span><span class="p">:</span>
                        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                        <span class="o">*</span><span class="n">balanced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="cm">/* if (cmpval &lt; 0) */</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmpval</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* move to right */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">bitree_right</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">avl_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">AvlNode</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">avl_data</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="n">avl_data</span><span class="o">-&gt;</span><span class="n">hidden</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">avl_data</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">bitree_ins_right</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">avl_data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="o">*</span><span class="n">balanced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bitree_right</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">),</span> <span class="n">data</span><span class="p">,</span> <span class="n">balanced</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="cm">/* ensure that the tree remains balanced */</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">balanced</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">switch</span> <span class="p">(((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">case</span> <span class="nl">AVL_LFT_HEAVY</span><span class="p">:</span>
                        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                        <span class="o">*</span><span class="n">balanced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="nl">AVL_BALANCED</span><span class="p">:</span>
                        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_RGT_HEAVY</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="nl">AVL_RGT_HEAVY</span><span class="p">:</span>
                    <span class="n">rotate_right</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
                    <span class="o">*</span><span class="n">balanced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="cm">/* if (cmpval &gt; 0) */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* handle finding a copy of the data */</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">hidden</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* do nothing since the data is in the tree and not hidden */</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="cm">/* insert the new data and mark it as not hidden */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                    <span class="cm">/* destroy the hidden data since it is being replaced */</span>
                    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">hidden</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

                <span class="cm">/* do not rebalance because the tree structure is unchanged */</span>
                <span class="o">*</span><span class="n">balanced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">statice</span> <span class="kt">int</span> <span class="nf">hide</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">cmpval</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* return that the data was not found */</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">cmpval</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">compare</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cmpval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* move to the left */</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">hide</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">bitree_left</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmpval</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* move to the right */</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">hide</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">bitree_right</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* mark the node as hidden */</span>
        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">hidden</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lookup</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">cmpval</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* return that the data was not found */</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">cmpval</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">compare</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cmpval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* move to the left */</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">bitree_left</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmpval</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* move to the right */</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">bitree_right</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">hidden</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* pass back the data from the tree */</span>
            <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* return that the data was not found */</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bistree_init</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">),</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">))</span>
<span class="p">{</span>
    <span class="cm">/* initialize the tree */</span>
    <span class="n">bitree_init</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">destroy</span><span class="p">);</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">compare</span> <span class="o">=</span> <span class="n">compare</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bistree_destroy</span><span class="p">(</span><span class="n">Bistree</span> <span class="o">*</span><span class="n">tree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* destroy all nodes in the tree */</span>
    <span class="n">destroy_left</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="cm">/* no operations are allowed now, but clear the structure as a precaution */</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BisTree</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bistree_insert</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">balanced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">insert</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bitree_root</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span> <span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">balanced</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bistree_remove</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">hide</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">bitree_root</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bistree_lookup</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">lookup</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">bitree_root</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="./tag/suan-fa.html">算法</a>
      <a href="./tag/c.html">C</a>
      <a href="./tag/ji-he.html">集合</a>
      <a href="./tag/shu-ju-jie-gou.html">数据结构</a>
    </p>
  </div>





</article>

    <footer>
<p>
  &copy;  2018 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Powered by <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
           src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Ivicel's Ambertime ",
  "url" : ".",
  "image": "/images/favicon.ico",
  "description": "ivicel's thoughts and writings"
}
</script>

</body>
</html>