<!DOCTYPE html>
<html lang="zh" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>Matserting Algorithms with C-7: 图 - Amber time</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="./matserting-algorithms-with-c-7-tu.html">

        <meta name="author" content="ivicel" />
        <meta name="keywords" content="算法,C,图,数据结构" />
        <meta name="description" content="图(Graphs) 图由顶点(vertices)和边(edges)组成, 图的边分为有向和无向 图表示为G=(V, E), V 代表顶点的集合, E 和 V 是一种二元关系 有向图: V={1, 2, 3, 4} 和 E = {(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 2), (3, 4)} 无向图: V={1, 2, 3 …" />

        <meta property="og:site_name" content="Amber time" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="Matserting Algorithms with C-7: 图"/>
        <meta property="og:url" content="./matserting-algorithms-with-c-7-tu.html"/>
        <meta property="og:description" content="图(Graphs) 图由顶点(vertices)和边(edges)组成, 图的边分为有向和无向 图表示为G=(V, E), V 代表顶点的集合, E 和 V 是一种二元关系 有向图: V={1, 2, 3, 4} 和 E = {(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 2), (3, 4)} 无向图: V={1, 2, 3 …"/>
        <meta property="article:published_time" content="2017-04-02" />
            <meta property="article:section" content="Data Structure Algorithms" />
            <meta property="article:tag" content="算法" />
            <meta property="article:tag" content="C" />
            <meta property="article:tag" content="图" />
            <meta property="article:tag" content="数据结构" />
            <meta property="article:author" content="ivicel" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="./theme/css/bootstrap.min.css" type="text/css"/>
    <link href="./theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="./theme/css/pygments/emacs.css" rel="stylesheet">
    <link rel="stylesheet" href="./theme/css/style.css" type="text/css"/>
        <link href="./theme/css/custom.css" rel="stylesheet">





</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="./" class="navbar-brand">
Amber time            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li >
                            <a href="./category/android.html">Android</a>
                        </li>
                        <li >
                            <a href="./category/c-language.html">C language</a>
                        </li>
                        <li class="active">
                            <a href="./category/data-structure-algorithms.html">Data structure algorithms</a>
                        </li>
                        <li >
                            <a href="./category/database.html">Database</a>
                        </li>
                        <li >
                            <a href="./category/java.html">Java</a>
                        </li>
                        <li >
                            <a href="./category/javascript.html">Javascript</a>
                        </li>
                        <li >
                            <a href="./category/python.html">Python</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-sm-9">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="./matserting-algorithms-with-c-7-tu.html"
                       rel="bookmark"
                       title="Permalink to Matserting Algorithms with C-7: 图">
                        Matserting Algorithms with C-7: 图
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2017-04-02T00:00:00+08:00"> Sun 02 April 2017</time>
    </span>





<span class="label label-default">Tags</span>
	<a href="./tag/suan-fa.html">算法</a>
        /
	<a href="./tag/c.html">C</a>
        /
	<a href="./tag/tu.html">图</a>
        /
	<a href="./tag/shu-ju-jie-gou.html">数据结构</a>
        
</footer><!-- /.post-info -->                    </div>
                </div>
                <h3 id="graphs">图(Graphs)</h3>
<p><img alt="图" src="../images/图.png" /></p>
<p>图由<strong>顶点</strong>(vertices)和<strong>边</strong>(edges)组成, 图的边分为<strong>有向</strong>和<strong>无向</strong></p>
<p>图表示为<code>G=(V, E)</code>, V 代表顶点的集合, E 和 V 是一种二元关系</p>
<blockquote>
<p>有向图: V={1, 2, 3, 4} 和 E = {(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 2), (3, 4)}</p>
<p>无向图: V={1, 2, 3, 4} 和 E = {(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)}</p>
<p>有向图中<code>(1, 2)</code>代表中顶点 <code>1</code>指向顶点<code>2</code></p>
</blockquote>
<p>图中两个重要关系是<strong>邻接</strong>(adjacency)和<strong>关联</strong>(incidence)</p>
<blockquote>
<p>无向图中, 顶点相连就是邻接, 而在有向图中, 只有两个顶点都相互指向对方是才是邻接的, 上图 1 和 2 就不邻接</p>
<p>关联是指顶点和边之间的关系. 有向图<code>(1, 2)</code>中称<code>1</code>关联到<code>2</code>, 无向图都是相互关联的</p>
<p>顶点的入度(in-degree)是指以顶点为终点的边的数目</p>
<p>顶点的出度(out-degree)是指以顶点为起点的边的数目</p>
<p>无向图中入度和出度都指顶点边的数目</p>
</blockquote>
<p><strong>路径</strong>是依次遍历顶点序列之间的边所形成的轨迹. 如果存在一条<code>u</code>到<code>u&lt;sup&gt;'&lt;/sup&gt;</code>的路径, 则称<code>u</code>到<code>u&lt;sup&gt;'&lt;/sup&gt;</code>是可达的. 没有重复顶点的路径称为<strong>简单路径</strong></p>
<p>如果从某顶点出发, 最后能够返回该顶点, 则称该路径为<strong>环</strong></p>
<p>如果图中的每个顶点都能通过某条路径到达其他顶点, 对于无向图则称为<strong>连通</strong>, 对有向图称为<strong>强连通</strong>. 如果只有图中部分是连通的, 无向图中称为<strong>连通分支</strong>, 有向图中称为<strong>强连通分支</strong>. 如果移除某个结点, 使得图或分支推动连通性, 则称该顶点为<strong>关结点</strong>. 如果移除某条边使得图失去连通性, 则称该边为<strong>桥</strong></p>
<p>计算机中通常使用<strong>邻接链表</strong>(adjacency-list representation)来表示图. 邻接表按照链表的方式组织, 链表中的每个结构都包含两个成员: 一个顶点和与该顶点邻接的顶点所组成的一个邻接表</p>
<p>有向图中, 邻接表的顶点总数同总的边数相等; 无向图中, 邻接表的顶点总数是边的两倍</p>
<p><img alt="邻接表" src="../images/邻接表.png" /></p>
<ul>
<li><strong>搜索方法</strong></li>
</ul>
<h4 id="breadth-first-search">广度优先算法(breadth-first search)</h4>
<p>在进一步探索图中的顶点之前先访问当前顶点的所有邻接结点.</p>
<blockquote>
<ol>
<li>开始前, 首先选择一个起始顶点并将其涂成灰色, 而其他顶点为白色. 然后把起始点单独置于一个队列中.  </li>
<li>对于队列中的每个顶点(初始状态下只有起始顶点), 依次找出和队列首部顶点相邻接的顶点, 将其涂成灰色然后加入到队列末尾.  </li>
<li>将队列首部顶点涂黑表示已经访问过, 然后出队; 继续访问下一个首部顶点, 回到第 3 步继续查找相邻接的顶点; 如果相邻接的顶点是白色, 表示还没有发现它, 将其涂成灰色, 并把它入队到末尾.  </li>
<li>直到队列中没有任何顶点时, 完成搜索</li>
</ol>
</blockquote>
<p><img alt="图广度优先算法" src="../images/图广度优先算法.png" /></p>
<h4 id="depth-first-search">深度优先算法(depth-first search)</h4>
<p>在访问某个顶点后, 递归地访问此顶点的所有未访问过的相邻顶点, 尽可能深的持续探索直到无法继续为止</p>
<blockquote>
<ol>
<li>选择一个起始点并涂成灰色加入到栈中, 其他顶点涂为白色.  </li>
<li>查找该顶点所有的邻接顶点, 如果是白色表示尚未发现该顶点, 则把该顶点涂成灰色并加入到栈中.  </li>
<li>最后加入也即是栈顶的顶点, 以该顶点为起始点重复第 2 步; 这样依次循环递归第 2 和 3 步骤, 直到栈顶邻接的顶点全涂成灰色, 或是没有邻接的顶点</li>
<li>当栈顶顶点没有邻接时或是邻接全是灰色时, 将栈顶涂成黑色, 表示已经访问过该顶点, 然后将其出栈.  </li>
<li>对栈顶重复第 2, 3, 4 步骤, 直到所有的顶点都出栈.  </li>
<li>当栈中所有顶点都出栈后, 如果图中还有白色顶点, 则选择其中的任意一个作为起始点, 从第 2 步骤开始, 直至图中所有的顶点都被涂成黑色</li>
</ol>
</blockquote>
<p><img alt="图广度优先算法" src="../images/图广度优先算法.png" /></p>
<p>图抽象数据类型头文件</p>
<div class="highlight"><pre><span></span><span class="cm">/* graph.h */</span>
<span class="cp">#ifndef GRAPH_H</span>
<span class="cp">#define GRAPH_H</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;list.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;set.h&quot;</span><span class="cp"></span>

<span class="cm">/* 邻接链表顶点结构 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">AdjList_</span> <span class="p">{</span>
    <span class="cm">/* 顶点数据 */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">vertex</span><span class="p">;</span>
    <span class="cm">/* 邻接顶点集合 */</span>
    <span class="n">Set</span> <span class="n">adjacent</span><span class="p">;</span>
<span class="p">}</span><span class="n">AdjList</span><span class="p">;</span>

<span class="cm">/* 图结构 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Graph_</span> <span class="p">{</span>
    <span class="cm">/* 图中顶点数量 */</span>
    <span class="kt">int</span> <span class="n">vcount</span><span class="p">;</span>
    <span class="cm">/* 图中边的数量 */</span>
    <span class="kt">int</span> <span class="n">ecount</span><span class="p">;</span>

    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="cm">/* 链表 */</span>
    <span class="n">List</span> <span class="n">adjlists</span><span class="p">;</span>
<span class="p">}</span><span class="n">Graph</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="n">VertexColor_</span> <span class="p">{</span><span class="n">white</span><span class="p">,</span> <span class="n">gray</span><span class="p">,</span> <span class="n">black</span><span class="p">}</span> <span class="n">VertexColor</span><span class="p">;</span>
<span class="cm">/* 初始化 */</span>
<span class="kt">void</span> <span class="nf">graph_init</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">),</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>
<span class="cm">/* 销毁 */</span>
<span class="kt">void</span> <span class="nf">graph_destroy</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">);</span>
<span class="cm">/* 插入顶点 */</span>
<span class="kt">int</span> <span class="nf">graph_ins_vertex</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="o">:</span>
<span class="cm">/* 在 data1 和 data2 中建立邻接关系 */</span>
<span class="kt">int</span> <span class="n">graph_ins_edge</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data2</span><span class="p">);</span>
<span class="cm">/* 删除顶点 */</span>
<span class="kt">int</span> <span class="nf">graph_rem_vertex</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 删除边 */</span>
<span class="kt">int</span> <span class="nf">graph_rem_edge</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 取得顶点的邻接表 */</span>
<span class="kt">int</span> <span class="nf">graph_adjlist</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">AdjList</span> <span class="o">**</span><span class="n">adjlist</span><span class="p">);</span>
<span class="cm">/* 判断 data2 是否是 data1 的邻接点 */</span>
<span class="kt">int</span> <span class="nf">graph_is_adjacent</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data2</span><span class="p">);</span>

<span class="cp">#define graph_adjlists(graph) ((graph)-&gt;adjlists)</span>
<span class="cp">#define graph_vcount(graph) ((graph)-&gt;vcount)</span>
<span class="cp">#define graph_ecount(graph) ((graph)-&gt;ecount)</span>

<span class="cp">#endif</span>
</pre></div>


<p>图的实现</p>
<div class="highlight"><pre><span></span><span class="cm">/* graph.c */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graph.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;list.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;set.h&quot;</span><span class="cp"></span>

<span class="cm">/* 初始化 */</span>
<span class="kt">void</span> <span class="nf">graph_init</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">),</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">graph</span><span class="o">-&gt;</span><span class="n">vcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">graph</span><span class="o">-&gt;</span><span class="n">ecount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">graph</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">;</span>
    <span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">=</span> <span class="n">match</span><span class="p">;</span>
    <span class="cm">/* 初始化图链表 */</span>
    <span class="n">list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* 销毁 */</span>
<span class="kt">void</span> <span class="nf">graph_destroy</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">AdjList</span> <span class="o">*</span><span class="n">adjlist</span><span class="p">;</span>

    <span class="cm">/* 删除每一个顶点 */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">list_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 删除链表结点 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list_rem_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">adjlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 释放顶点的邻接顶点 */</span>
            <span class="n">set_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">adjacent</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">graph</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">free</span><span class="p">(</span><span class="n">adjlist</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* 删除链表 */</span>
    <span class="n">list_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Graph</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">graph_ins_vertex</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">;</span>
    <span class="n">AdjList</span> <span class="o">*</span><span class="n">adjlist</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

    <span class="cm">/* 确认没有重复数据存在图中链表里 */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertext</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* 顶点内存 */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">adjlist</span> <span class="o">=</span> <span class="p">(</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">AdjList</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
    <span class="cm">/* 初始化新顶点邻接点 */</span>
    <span class="n">set_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">adjacent</span><span class="p">,</span> <span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="cm">/* 将新顶点插入到链表尾部 */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">list_ins_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">,</span> <span class="n">list_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">),</span>
        <span class="n">adjlist</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* 增加顶点数量 */</span>
    <span class="n">graph</span><span class="o">-&gt;</span><span class="n">vcount</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">graph_ins_edge</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

    <span class="cm">/* 查找是否存在顶点数据 data2 */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> 
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">data2</span><span class="p">,</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* 顶点不存在 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 查找是否存在顶点数据 data1 */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> 
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* 顶点不存在 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* 插入边关系集合 </span>
<span class="cm">     * 邻接点集合里结点数据指向实际的数据, 而不是顶点结构</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">set_insert</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">adjacent</span><span class="p">,</span> <span class="n">data2</span><span class="p">)))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">graph</span><span class="o">-&gt;</span><span class="n">ecount</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* 删除顶点 */</span>
<span class="kt">int</span> <span class="nf">graph_rem_vertex</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">AdjList</span> <span class="o">*</span><span class="n">adjlist</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/*遍历链表中所有顶点, 找到匹配的顶点和邻接点 */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* 当该顶点是其他顶点的邻接点时, 不允许删除 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">set_is_memember</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">adjacent</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/* 找到匹配的顶点位置 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
            <span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* 未找到符合顶点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* 不能删除有还有邻接点的顶点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">set_size</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">adjacent</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* 删除顶点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">list_rem_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">adjlist</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">adjlist</span><span class="p">);</span>

    <span class="n">graph</span><span class="o">-&gt;</span><span class="n">vcount</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">graph_rem_edge</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data1</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">;</span>
    <span class="cm">/* 查找第一个顶点 */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* 将顶点的邻接边删除 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">set_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">adjacent</span><span class="p">,</span> <span class="n">data2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">graph</span><span class="o">-&gt;</span><span class="n">ecount</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* 取得顶点 */</span>
<span class="kt">int</span> <span class="nf">graph_adjlist</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">AdjList</span> <span class="o">**</span><span class="n">adjlist</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="cm">/* locate the adjacency list for the vertex */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* return if the vertex was not found */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* pass back the adjacency list for the vertex */</span>
    <span class="o">*</span><span class="n">adjlist</span> <span class="o">=</span> <span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* 判断邻接关系 */</span>
<span class="kt">int</span> <span class="nf">graph_is_adjacent</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data2</span><span class="p">)</span>
<span class="p">{</span>   
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">set_is_memember</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">adjacent</span><span class="p">,</span> <span class="n">data2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>图的应用: 计算网络跳数(Counting Network Hops)</p>
<p><img alt="网络跳数" src="https://ivicel.github.io/images/网络跳数.png" /></p>
<p>使用广度优先算法, 对于某个顶点的的邻接点, 其邻接点的跳数都等于该顶点跳数加上 1</p>
<div class="highlight"><pre><span></span><span class="cm">/* bfs.c */</span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graph.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;list.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;queue.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;set.h&quot;</span><span class="cp"></span>


<span class="cm">/* define a struct for vertices in a breadth-first search */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">BfsVertext_</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="cm">/* 顶点颜色 */</span>
    <span class="n">VertexColor</span> <span class="n">color</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">hops</span><span class="p">;</span>
<span class="p">}</span><span class="n">BfsVertex</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="n">BfsVertex</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="n">List</span> <span class="o">*</span><span class="n">hops</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Queue</span> <span class="n">queue</span><span class="p">;</span>
    <span class="n">AdjList</span> <span class="o">*</span><span class="n">adjlist</span><span class="p">,</span> <span class="o">*</span><span class="n">clr_adjlist</span><span class="p">;</span>
    <span class="n">BfsVertex</span> <span class="o">*</span><span class="n">clr_vertex</span><span class="p">,</span> <span class="o">*</span><span class="n">adj_vertex</span><span class="p">;</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="o">*</span><span class="n">member</span><span class="p">;</span>

    <span class="cm">/* 初始化顶点颜色 */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph_adjlists</span><span class="p">(</span><span class="n">graph</span><span class="p">));</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">clr_vertex</span> <span class="o">=</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">clr_vertex</span><span class="p">,</span> <span class="n">start</span><span class="p">))</span> <span class="p">{</span>
            <span class="cm">/* 确定起点 */</span>
            <span class="n">clr_vertex</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">gray</span><span class="p">;</span>
            <span class="n">clr_vertex</span><span class="o">-&gt;</span><span class="n">hops</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">clr_vertex</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">white</span><span class="p">;</span>
            <span class="n">clr_vertex</span><span class="o">-&gt;</span><span class="n">hops</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* 取得起始顶点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">graph_adjlist</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clr_adjlist</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 将起始点加入队列中 */</span>
    <span class="n">queue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">queue_enqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="n">clr_adjlist</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">queue_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* 循环队列, 广度优先 */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">queue_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">adjlist</span> <span class="o">=</span> <span class="n">queue_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
        <span class="cm">/* 循环邻接点 */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">member</span> <span class="o">=</span> <span class="n">set_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">adjacent</span><span class="p">);</span> <span class="n">member</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="n">member</span> <span class="o">=</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 注意集合结点存储的数据指向并不是一个顶点, 而是顶点指向的实际数据 */</span>
            <span class="n">adj_vertex</span> <span class="o">=</span> <span class="n">set_data</span><span class="p">(</span><span class="n">member</span><span class="p">);</span>
            <span class="cm">/* 确认顶点存在于图中 */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">graph_adjlist</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">adj_vertex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clr_adjlist</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">queue_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">clr_vertex</span> <span class="o">=</span> <span class="n">clr_adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">clr_vertex</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">white</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* 如果顶点还没有添加到队列中, 将其涂成灰色并加入到队列里 */</span>
                <span class="n">clr_vertex</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">gray</span><span class="p">;</span>
                <span class="cm">/*  队列首部顶点到达这个顶点所需跳数 + 1, 也即是起始点到该点的跳数 */</span>
                <span class="n">clr_vertex</span><span class="o">-&gt;</span><span class="n">hops</span> <span class="o">=</span> <span class="p">((</span><span class="n">BfsVertex</span> <span class="o">*</span><span class="p">)</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hops</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">queue_enqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="n">clr_adjlist</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">queue_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* 队首部出队, 涂成黑色 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">queue_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">adjlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">((</span><span class="n">BfsVertex</span> <span class="o">*</span><span class="p">)</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">black</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">queue_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* 完成循环成销毁队列 */</span>
    <span class="n">queue_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
    <span class="cm">/* 初始一个队列 hops */</span>
    <span class="n">list_init</span><span class="p">(</span><span class="n">hops</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph_adjlist</span><span class="p">(</span><span class="n">graph</span><span class="p">));</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">clr_vertex</span> <span class="o">=</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">;</span>
        <span class="cm">/* 对于 hops 值为即为到达该顶点所需最少跳数, -1 是不可到达的顶点 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">clr_vertex</span><span class="o">-&gt;</span><span class="n">hops</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">list_ins_next</span><span class="p">(</span><span class="n">hops</span><span class="p">,</span> <span class="n">list_tail</span><span class="p">(</span><span class="n">hops</span><span class="p">),</span> <span class="n">clr_vertex</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">list_destroy</span><span class="p">(</span><span class="n">hops</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>图的应用: 拓扑排序(Topological Sorting)</p>
<div class="highlight"><pre><span></span><span class="cm">/* dfs.c */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graph&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;list.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;set.h&quot;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">DfsVertex_</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="n">VertexColor</span> <span class="n">color</span><span class="p">;</span>
<span class="p">}</span><span class="n">DfsVertex</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dfs_main</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="n">AdjList</span> <span class="o">*</span><span class="n">adjlist</span><span class="p">,</span> <span class="n">List</span> <span class="o">*</span><span class="n">ordered</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">AdjList</span> <span class="o">*</span><span class="n">clr_adjlist</span><span class="p">;</span>
    <span class="n">DfsVertex</span> <span class="o">*</span><span class="n">clr_vertex</span><span class="p">,</span> <span class="o">*</span><span class="n">adj_vertex</span><span class="p">;</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">member</span><span class="p">;</span>
    <span class="cm">/* change the color of vertex to gray */</span>
    <span class="p">((</span><span class="n">DfsVertex</span> <span class="o">*</span><span class="p">)</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">gray</span><span class="p">;</span>
    <span class="cm">/* search its adjacency set */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">member</span> <span class="o">=</span> <span class="n">set_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">adjacent</span><span class="p">);</span> <span class="n">member</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">member</span> <span class="o">=</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* determine the color of the next adjacent vertex */</span>
        <span class="n">adj_vertex</span> <span class="o">=</span> <span class="n">set_data</span><span class="p">(</span><span class="n">member</span><span class="p">);</span>
        <span class="cm">/* 取得该顶点 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graph_adjlist</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">adj_vertex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clr_adjlist</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">clr_vertex</span> <span class="o">=</span> <span class="n">clr_adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">;</span>
        <span class="cm">/* move one vertex deeper when the next adjacent vertex is white */</span>
        <span class="cm">/* 如果顶点是白色, 表明还没被访问过, 如果有邻接点, 继续向下层访问 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">clr_vertex</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">white</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dfs_main</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">clr_adjlist</span><span class="p">,</span> <span class="n">ordered</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* color the current vertex black and make it first in the list */</span>
    <span class="p">((</span><span class="n">DfsVertex</span> <span class="o">*</span><span class="p">)</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">black</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">list_ins_next</span><span class="p">(</span><span class="n">ordered</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="n">DfsVertex</span> <span class="o">*</span><span class="p">)</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="n">List</span> <span class="o">*</span><span class="n">ordered</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DfsVertex</span> <span class="o">*</span><span class="n">vertex</span><span class="p">;</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">;</span>

    <span class="cm">/* initial all of the vertices in the graph */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">vertex</span> <span class="o">=</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">;</span>
        <span class="n">vertex</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">white</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* initialize list */</span>
    <span class="n">list_init</span><span class="p">(</span><span class="n">ordered</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="cm">/* perform depth-first search */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* ensure that every component of unconnected graphs is searched */</span>
        <span class="n">vertex</span> <span class="o">=</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vertex</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">white</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 确保所有顶点遍历到, 发生错误就退出 */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dfs_main</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="p">(</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">),</span> <span class="n">ordered</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">list_destroy</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
        <div class="col-sm-3" id="sidebar">
            <aside>

<section class="well well-sm">
    <ul class="list-group list-group-flush">
        <li class="list-group-item"><h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Social</span></h4>
              <ul class="list-group" id="social">
                <li class="list-group-item"><a href="#"><i class="fa fa-you-can-add-links-in-your-config-file-square fa-lg"></i> You can add links in your config file</a></li>
                <li class="list-group-item"><a href="#"><i class="fa fa-another-social-link-square fa-lg"></i> Another social link</a></li>
              </ul>
            </li>





    <li class="list-group-item"><h4><i class="fa fa-external-link-square fa-lg"></i><span class="icon-label">Links</span></h4>
      <ul class="list-group" id="links">
        <li class="list-group-item">
            <a href="http://getpelican.com/" target="_blank">
                Pelican
            </a>
        </li>
        <li class="list-group-item">
            <a href="http://python.org/" target="_blank">
                Python.org
            </a>
        </li>
        <li class="list-group-item">
            <a href="http://jinja.pocoo.org/" target="_blank">
                Jinja2
            </a>
        </li>
        <li class="list-group-item">
            <a href="#" target="_blank">
                You can modify those links in your config file
            </a>
        </li>
      </ul>
    </li>
    </ul>
</section>            </aside>
        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2018 ivicel
            &middot; Powered by <a href="https://github.com/getpelican/pelican-themes/tree/master/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="./theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="./theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="./theme/js/respond.min.js"></script>


</body>
</html>